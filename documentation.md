## New Learnings
- Consistent styling across shared components helps maintain UI uniformity between edit and create forms
- When sharing styles between components, it's important to include all style variations for MUI components (Select, Button, etc.) to maintain consistency
- Extracting shared styles to a common location helps maintain consistency and reduces duplication
- Adding MenuProps to Select components ensures consistent dropdown behavior across forms
- Consistent flex container spacing and layout structure helps maintain visual alignment between related components
- Using shared commonInputStyles across form components ensures visual consistency between edit and create forms
- Consistent MenuProps configuration helps maintain uniform dropdown behavior across the application
- Component styling consistency requires matching both the internal component styles and the wrapper/container styling
- Button styling consistency includes matching icon usage, text display, and layout spacing across similar action buttons
- Consistent image preview sizes help maintain visual harmony across different form views
- Using space-y-2 utility class provides consistent vertical spacing between form elements
- Label styling consistency is important for maintaining visual hierarchy across forms
- Maintaining consistent help text and user guidance across forms helps provide a uniform user experience
- Keeping imports clean and removing unused ones helps maintain code consistency across components
- Consistent styling for location selection components helps maintain visual harmony between create and edit forms
- Using MUI's sx prop with nested selectors allows for detailed styling control of Autocomplete and TextField components
- Maintaining consistent spacing and layout between location components helps create a unified user experience
- Ensuring consistent styling across related components (AddressSearch and LocationSelect) maintains visual coherence in the location selection feature
- Using shared style definitions like commonInputStyles helps maintain consistency even in nested components like AddressSearch
- Consistent label structure (using separate label elements instead of TextField labels) helps maintain visual hierarchy across form components
- Consistent dropdown height settings across all form components (including Autocomplete) improve visual uniformity
- Regular cleanup of unused imports helps maintain code cleanliness and reduces bundle size
- Extracting commonly used UI patterns like tips into reusable components helps maintain consistent styling and reduces duplication
- When migrating to shared components, it's important to remove duplicate fields to maintain a single source of truth
- Sharing form components between create and edit views ensures consistent user experience and reduces code duplication
- When sharing form components between edit and create forms, keeping the event handling consistent helps prevent type mismatches
- Direct handler passing is preferable to complex event transformations when the base event types are compatible
- SelectChangeEvent from MUI and React.ChangeEvent<HTMLInputElement> can be used interchangeably for basic form handling
- When integrating shared components, maintaining consistent event handling patterns helps preserve existing functionality
- When integrating shared components, adapting event handlers to match existing patterns helps maintain backwards compatibility
- When integrating shared location components, maintaining consistent location data structure helps ensure compatibility
- Using shared location selection components helps maintain consistent geocoding behavior across the application
- Consistent location display formatting between create and edit views improves user experience
- Centralizing file reading logic in shared components reduces duplication and ensures consistent behavior
- When standardizing component interfaces, updating type definitions is crucial for maintaining type safety
- When modifying shared interfaces, making fields optional helps maintain backwards compatibility
- Consistent image preview handling between create and edit forms improves user experience
- Synthetic events should be avoided when direct handler passing is possible
- Complex synthetic events can be replaced with simpler event objects that match the expected interface
- Consistent event handling patterns improve code maintainability and readability
- When standardizing interfaces, all parameters should be used consistently across implementations
- Simplifying component usage improves code maintainability and reduces potential errors
- Event handler functions that don't depend on component state should be defined outside the component
- Using proper event creation methods improves type safety over simple type assertions
- Using optional chaining for event handlers improves type safety and prevents runtime errors
- Keep event transformation logic in the component that knows about the event structure
- Standardize event handling patterns across similar form components
- Move complex event handling logic out of parent components
- Keep all related event transformation logic in one place
- Simplify component interfaces by handling transformations internally
- Reduce prop surface area when possible to improve maintainability
- Keep related state cleanup logic with the component that manages the state
- Simplify parent interfaces by moving cleanup logic into child components
- Standardize state management patterns across similar components
- Keep form field clearing logic with the component that manages the field
- Minimize parent component responsibilities for child state management
- Let child components handle their own cleanup logic
- Be explicit about event types when standardizing form interfaces
- Use type assertions judiciously to maintain compatibility with existing handlers
- Keep event type definitions focused on actually used event types
- Use optional callbacks to support different form behaviors
- Keep state management consistent while allowing for form-specific cleanup
- Make component interfaces flexible enough to handle different use cases
- Pass cleanup callbacks directly instead of wrapping in conditional logic
- Keep form-specific cleanup handlers at the form level
- Allow child components to handle common state management while forms handle specific cleanup
- Keep state management patterns identical between similar form implementations
- Avoid wrapping simple state setters in conditional logic
- Let child components fully manage their internal state transitions
- Use React naming conventions for state setters (setX instead of onXChange)
- Keep prop names consistent with their actual function
- Follow React patterns for state management props
- Combine related state changes into single handlers for clarity
- Keep state transitions predictable and centralized
- Group related state management logic together
- Extract common event creation patterns into helper functions
- Keep event creation consistent across similar handlers
- Use utility functions to reduce code duplication in event handling
- Use higher-order functions to create consistent field handlers
- Reduce boilerplate by generating similar handlers
- Keep field change handling patterns consistent
- Include all possible event types in shared component interfaces
- Make type definitions comprehensive enough to handle all use cases
- Keep event type handling consistent across form implementations
- Keep event type handling consistent from hooks to components
- Define comprehensive event types at the hook level
- Ensure form hooks can handle all component event types
- Use consistent type assertions across similar form components
- Keep event type handling identical between edit and create forms
- Apply type standardization to all component usages
- Extract common event types to reduce duplication
- Use type aliases to improve code readability
- Keep type assertions simple and consistent
- Propagate shared types through component interfaces
- Remove type assertions when interfaces match
- Keep type definitions consistent across component hierarchy
- Include all state management props in component interfaces
- Keep state setter props consistent with component usage
- Ensure parent components expose required state management functions
- Make props required when they represent core functionality
- Use no-op functions to satisfy required props when no action is needed
- Keep component interfaces identical between different usages
- Follow same naming patterns as IdentificationFields for consistency
- Use optional callbacks to handle form-specific cleanup
- Keep component interfaces aligned across similar form fields
- Keep color state cleanup logic with color component
- Use consistent state management patterns across form fields
- Follow same patterns established in IdentificationFields
- Keep state setter props consistent across form components
- Follow same state management patterns for similar fields
- Ensure parent components expose all required state setters
- Use consistent event creation patterns across form components
- Keep color validation logic with color component
- Make color state changes predictable and clear
- Extract complex validation logic into focused functions
- Keep related color validation together
- Make color conflict handling reusable
- Keep component-specific labels within components
- Encapsulate component styling for better reusability
- Remove styling duplication from parent components
- Handle both add and remove actions consistently
- Keep form-specific handlers optional but available
- Ensure all form actions have corresponding handlers
- Keep state transition logic with the component managing the state
- Handle optional callbacks in state change handlers
- Make state transitions and side effects consistent
- Order of state updates matters for form functionality
- Call parent handlers before updating local state
- Keep state transitions synchronized between parent and child
- Keep form-specific configuration in props
- Make component behavior configurable but with sensible defaults
- Handle loading states consistently across form components
- Pass form-specific loading states to shared components
- Configure zoom levels based on form context
- Keep shared component usage consistent between forms
- Extract magic numbers into named constants
- Combine loading states for better UX
- Make configuration values reusable across components
- Extract complex async operations into focused functions
- Keep related location processing logic together
- Make async state transitions more predictable
- Keep configuration constants in dedicated files
- Use TypeScript to enforce valid zoom levels
- Centralize shared configuration values
- Use shared constants instead of magic numbers
- Keep zoom level values consistent across application
- Reference shared constants directly in components
- Keep constants in organized directory structure
- Use consistent import paths across components
- Follow index.ts pattern for constants exports
- Keep interface names consistent with component names
- Use shared interfaces for similar component props
- Ensure type imports match exported names
- Use proper React event types for component callbacks
- Handle null cases in async location processing
- Add type safety to MUI component callbacks
- Use shared interfaces for common data structures
- Keep type definitions consistent across related components
- Use Partial and Omit for flexible type definitions
- Use consistent return types in location handlers
- Ensure location data matches interface at all points
- Handle optional values consistently in location data
- Propagate shared interfaces through component hierarchy
- Keep location data types consistent in map interactions
- Use shared interfaces for map click events
- Use correct import paths for shared types
- Add proper type definitions for map libraries
- Handle map event types correctly
- Keep location data types consistent in map events
- Handle map events with proper type safety
- Use shared interfaces throughout map components
- Define interfaces for internal component state
- Use consistent types for map coordinates
- Keep coordinate handling type-safe
- Use nullish coalescing for all location fields
- Ensure location data matches interface before callback
- Keep location data creation patterns consistent
- When sharing form components between edit and create forms, all required handlers must be provided for full functionality
- Keep feature parity between similar forms by providing consistent handler functions
- Make form component behavior identical between different implementations by matching all required props
- When sharing form components between edit and create forms, avoid adding unnecessary props when existing props already provide the needed functionality
- Keep component interfaces minimal by using existing props instead of creating new ones for the same functionality
- Maintain consistent behavior between forms by using the same prop patterns for similar actions
- When debugging shared form components, track state changes at both parent and child component levels to identify where state updates might be failing
- Add strategic console logs to track user interactions and state updates in form components
- When debugging function props, inspect the complete function details including toString() representation
- Add thorough prop validation checks to identify both existence and correct type of function props
- Add detailed prop validation logging to catch undefined function props early in the component lifecycle
- Use type checking and error handling to prevent runtime crashes from undefined function props
- When debugging form components with multiple instances, track individual component state to identify instance-specific issues
- Add logging to shared components to verify prop values are being passed correctly through the component hierarchy
- When debugging prop issues, track the complete prop chain from parent to child to identify where props are being lost
- Add detailed prop type and value logging to identify prop definition mismatches
- When debugging prop chain issues, verify both the type definition and the actual prop passing in parent components
- Track prop values through the entire component hierarchy to identify where required props are missing
- When sharing form functionality between create and edit modes, ensure state management hooks are consistently used in both components
- Verify that state management hooks are properly initialized in both create and edit modes
- When using custom hooks, ensure all state setters are properly exposed in the hook's return object
- Verify that state setters are correctly passed through the entire component chain
- Check hook implementation when state management isn't working in one component but works in another
- When state setters aren't working, check if they're properly returned from custom hooks
- Ensure all required state management functions are included in hook return objects
- Verify hook implementation matches between create and edit forms for shared functionality
- Remove debugging logs once functionality is fixed to keep code clean
- Clean up temporary debugging code after resolving issues
- Maintain code cleanliness by removing diagnostic logging after debugging
- When using state management hooks, ensure all required state setters are properly destructured and passed down to child components
- TypeScript linting can help identify missing props that could cause runtime errors
- Optional callback props should be handled with optional chaining, while required state setters should be called directly
- Props interfaces must properly type state setter functions to avoid runtime errors
- State setter functions should be explicitly typed and wrapped when passed as props to ensure proper binding
- Component-level state management should be handled at the container level when dealing with edit/view modes
- Tailwind's space utilities should be adjusted based on component hierarchy and visual design requirements
- Nested space utilities should be carefully considered to avoid compounding spacing effects
- Consistent spacing between form sections improves visual hierarchy and readability
- Match spacing patterns across similar form components for visual consistency
- State management should be handled by the custom hook rather than component-level useState
- Verify state setter functions are properly typed in component prop interfaces
- Custom hooks must explicitly return all required state setters in their return object
- Order state transitions carefully to ensure proper synchronization between parent and child components
- Reusable UI components like buttons should include customizable labels for better accessibility and reuse
- When extracting common UI patterns, consider both visual consistency and semantic meaning
- Using default prop values allows components to maintain backwards compatibility while adding new features
- Component extraction should preserve existing data-testid patterns for testing consistency
- When extracting shared components, ensure test coverage remains consistent by preserving testIds
- Maintain consistent testIds across multiple instances of the same component type
- Extract common UI patterns like remove buttons to improve maintainability and consistency
- Preserve aria-label and accessibility features when extracting shared button components
- Keep error state styling consistent across similar destructive actions
- Maintain consistent icon usage across similar button types
- When creating shared button components, ensure aria-labels can be customized for specific contexts
- Maintain consistent aria-labels across similar actions (e.g., "Remove Color", "Remove Breed")
- Extract common layout patterns into reusable components to maintain consistent structure
- When components share similar layout patterns, create a flexible container component
- Use children prop to maintain component flexibility while standardizing layout
- Keep accessibility features like labels and ARIA attributes consistent across similar patterns
- Clean up debugging code after completing component refactoring
- Keep imports minimal by removing unused dependencies from shared components
- When creating similar selection components, maintain consistent prop patterns
- Use Autocomplete for better user experience in selection interfaces
- Reuse styling patterns across similar form components for consistency
- Keep component interfaces similar when they serve similar purposes
- Remove helper functions that are no longer needed after component extraction
- Clean up related imports when moving functionality to shared components
- Remove component imports that are now handled by child components
- Consider event handling consistency across the entire form when choosing between direct values and synthetic events
- Maintain consistent event patterns when components share the same parent handlers
- Maintain consistent type safety across similar form handlers
- Ensure event handler types match between parent and child components
- Match component prop types with existing form patterns for seamless integration
- Handle event type conversion within reusable components rather than at usage sites
- Handle nullable values consistently in component interfaces
- Match type definitions with actual usage patterns in parent components
- Preserve complex state update logic when refactoring event handlers
- Handle state dependencies in form hooks rather than individual components
- Match component prop types with parent data structures to avoid type coercion
- When using nested spacing utilities, separate distinct form sections to allow parent spacing to work consistently
- Maintain consistent spacing for similar form sections even when using shared components
- Use consistent margin sizes for similar form section types across components
- Let parent components control spacing to avoid competing margin rules in shared components
- Apply consistent margin wrappers to similar form sections to maintain visual rhythm
- Use consistent space-y utilities between similar form components to maintain spacing rhythm
- Avoid combining margin utilities with space utilities on parent elements to prevent spacing conflicts
- Use identical spacing utilities between similar form components to ensure visual consistency
- Position action buttons inline with their related form controls for better visual connection
- Session management requires both frontend and backend coordination
- Regular polling helps maintain active sessions
- Session renewal should happen on authenticated requests
- Same-site cookie settings affect session security
- Session duration should balance security with user experience
- Frontend state management should handle session expiration gracefully
- Sessions should persist until explicit logout rather than using automatic expiration for better user experience
- Map markers should only be displayed in interactive map modes to avoid visual clutter in read-only views
- State for map markers should be managed within the map component to maintain component encapsulation
- Using conditional rendering for map markers allows different behavior between read-only and interactive modes
- Map view initialization should only happen once to prevent unwanted zoom resets during user interaction
- State flags can help control when effects should run to prevent unwanted side effects
- Map zoom levels should remain consistent when transitioning between view and edit modes to maintain user context
- Map position and markers should update consistently whether location is selected via click or address search
- useEffect dependencies should include all values that could trigger map position updates
- Map view should update to show selected location regardless of selection method to maintain user context
- Map zoom level should be consistent regardless of location selection method to provide uniform user experience
- Using shared map zoom level constants ensures consistent zoom behavior across different form modes
- Higher zoom levels (18) provide better visibility for precise location selection in edit mode
- Map zoom levels should be consistently applied at the component level rather than relying on prop passing
- Map zoom levels should be controlled through props to maintain consistent behavior across different modes
- Using shared zoom level constants in view mode ensures consistent map display across the application
- Required props must be provided even in read-only modes to satisfy TypeScript interface requirements
- Shared components can help eliminate duplicate code while maintaining consistent styling and layout
- Complex geocoding functions should be extracted into dedicated services for better maintainability
- Map event handling logic should be separated from main map rendering component
- Breaking down complex components into smaller, focused pieces improves code organization
- Separating concerns in map components allows for better testing and maintenance
- Location processing logic should be isolated from UI rendering code
- Map state management should be handled in dedicated components
- Geocoding services should be centralized for reuse across the application
- Component responsibilities should be clearly defined and separated
- Map marker and event handling can be isolated from base map setup
- Loading and notification states should be managed in dedicated container components
- UI state management should be separated from core component functionality
- Container components can handle common UI patterns across multiple instances
- Component hierarchy should reflect logical state management boundaries
- Wrapper components can provide consistent loading and error states
- Render props can provide better type safety than component composition for shared state
- Container components should expose state management handlers through render props when needed
- State management should flow through explicit props rather than implicit context
- Component communication patterns should be type-safe and explicit
- Render props provide better control over state handler scoping
- Common types should be shared across related components
- Notification patterns should be consistent throughout the application
- Type definitions should be centralized when used across multiple components
- Shared interfaces improve maintainability and type consistency
- Type reuse helps enforce consistent patterns across components
- Magic numbers should be extracted into named constants
- Geographic constants should be shared across map components
- Default values should be centralized in constants files
- Coordinate values should be managed in a single location
- Constants should be properly typed for better maintainability
- Geographic coordinate types should be shared across the application
- Type definitions should cover all shared data structures
- Constant type definitions should match their usage patterns
- Type safety should extend to configuration constants
- Shared types help maintain consistency in geographic data handling
- Avoid duplicate type definitions across the application
- Consolidate related types into a single location
- Type definitions should be organized by domain rather than component
- Shared data structures should have a single source of truth
- Type imports are preferable to duplicate definitions
- Reuse coordinate types consistently across interfaces
- Props should leverage shared type definitions
- Interface composition should use consistent base types
- Type intersections can combine shared type definitions
- Prop types should align with their underlying data structures
- Component refactoring should include verification of all usage sites
- Type changes should be validated across all consuming components
- Coordinate handling should be consistent across all form types
- Component interfaces should be used consistently across the application
- Prop patterns should be standardized across similar form components
- Common initialization patterns should be extracted into helper functions
- Location data transformation should be consistent across components
- Helper functions can enforce consistent data structure usage
- Initialization logic should be centralized for maintainability
- Data transformation patterns should be reusable across components
- Helper functions should be used consistently throughout component hierarchy
- Location initialization should follow the same pattern at all levels
- Component composition should maintain consistent data transformation patterns
- Parent components should use the same helper functions as their children
- Data transformation helpers should be used at the highest appropriate level
- Helper function usage should be consistent across all form variants
- Create and edit forms should use the same data transformation patterns
- Location initialization should be handled identically in all contexts
- Form components should share the same helper functions regardless of type
- Consistent patterns improve maintainability across form variants
- Address processing logic belongs in dedicated services
- UI components should delegate complex data processing
- Geocoding operations should be centralized in services
- Components should focus on presentation and user interaction
- Service functions should handle all data transformation logic
- Remove unused imports after moving functionality
- Ensure proper type imports in service files
- Keep import statements clean and relevant
- Remove legacy dependencies after refactoring
- Maintain clean import paths after code reorganization
- Remove unused type definitions after refactoring
- Keep interface definitions minimal and relevant
- Clean up type definitions when simplifying components
- Remove interfaces when their usage is inlined
- Maintain clean type definitions after code reorganization
- Remove unused props when simplifying component behavior
- Keep component interfaces minimal and focused
- Remove configuration props when behavior is standardized
- Simplify component APIs when functionality is consolidated
- Maintain clean interfaces after removing unused features
- Remove unused props from component usage sites
- Keep component usage consistent across the application
- Update all consuming components when simplifying interfaces
- Maintain consistent prop patterns across form variants
- Clean up component usage after interface changes
- Remove unused constant imports after removing related functionality
- Clean up imports when removing feature dependencies
- Keep import statements aligned with actual component usage
- Remove configuration imports when standardizing behavior
- Maintain clean import statements after feature removal
- View components should use the same helper functions as edit/create
- Maintain consistent patterns across all component variants
- Helper functions should be used in read-only contexts
- Keep data transformation consistent in view components
- Standardize component usage across all modes
- Remove unused imports after standardizing component behavior
- Complete cleanup of configuration imports across all components
- Ensure consistent import cleanup across all component variants
- Keep imports minimal after standardizing functionality
- Maintain clean imports in view components
- Required props must be provided even in read-only mode
- Maintain type safety when simplifying components
- Keep required props consistent across all usages
- Default zoom levels should be explicitly provided
- Preserve component contracts when standardizing behavior
- Handle null values appropriately in data transformations
- Convert null to undefined for optional string properties
- Ensure type compatibility between source and target interfaces
- Transform nullable fields to match component expectations
- Maintain type safety when converting between data formats
- Helper functions should handle multiple input types
- Convert between null and undefined explicitly when types differ
- Support both form and API data structures in helpers
- Ensure type compatibility with both new and existing data
- Handle type conversions at the helper function level
- Import all required types for helper functions
- Keep type imports complete and explicit
- Ensure all used types are properly imported
- Maintain clean type dependencies
- Import domain types in utility functions
- Form submission logic should be encapsulated in dedicated hooks
- State management should be centralized in custom hooks rather than components
- Form population handlers should use consistent interfaces
- Component interfaces should be minimal and focused on required functionality
- State transitions should be managed through dedicated handlers
- Image handling logic belongs in form management hooks
- Field visibility logic should be managed consistently through hooks
- Form state setters should be exposed through dedicated handlers
- Component interfaces should avoid exposing raw state setters
- Form population should use consistent patterns across the application
- Form initialization logic should be handled in custom hooks
- Effects that manage form state should live with other state management code
- Keep components focused on rendering and event delegation
- Keep initialization functions private when only used internally
- Custom hooks should expose minimal public interfaces
- Internal hook functions don't need to be exposed if only used by effects
- Remove unused props to maintain clean component interfaces
- Keep component props aligned with actual functionality
- Use utility functions to their full potential to reduce code complexity
- Prefer built-in null handling in utility functions over inline checks
- Keep data transformation logic in custom hooks
- Simplify component JSX by moving conditional logic to hooks
- Keep imports close to where they are used
- Move utility imports to hooks when logic is encapsulated
- Remove unused handlers when refactoring form logic
- Keep hook interfaces focused on currently used functionality
- Remove type imports when their associated functionality is removed
- Keep type imports minimal and focused on current usage
- Use higher-order functions to reduce handler duplication
- Keep state update patterns consistent across similar fields
- Use consistent patterns for similar state setters
- Extract common state setting patterns into reusable functions
- Use higher-order functions for similar state cleanup operations
- Keep state cleanup patterns consistent across field types
- Group higher-order functions with their instantiations
- Keep related function declarations together for better readability
- Keep state declarations close to their related handlers
- Group related state management code for better maintainability
- Keep visibility state management code together
- Group related state management patterns for better organization
- Keep related field management functions together
- Group show/hide and removal logic for better maintainability
- Keep all color-related handlers together
- Group field value and visibility management by field type
- Keep form input handlers close to their usage
- Group form data management functions for better organization
- Keep state declarations at the top of hooks
- Group related state declarations together
- Group hook return values by related functionality
- Keep hook interfaces organized by feature area
- Use useCallback for functions that depend on state
- Properly handle state dependencies in hook functions
- Memoize functions that use state setters
- Use proper dependency arrays in effects and callbacks
- Memoize handlers that use state setters
- Use useCallback for form input handlers
- Memoize higher-order functions that use state setters
- Use useCallback for handler factory functions
- Using specific function types instead of React.SetStateAction helps prevent unwanted state transformations
- State setter types should match their actual usage patterns to maintain data integrity
- Form data setters should preserve exact input values without transformation
- Direct state setters are preferable when exact value preservation is required
- Form input handlers should preserve exact input values without transformation
- State updates should maintain data integrity by avoiding implicit transformations
- Input event handlers should preserve the original case of text input
- Direct value assignment is preferable to implicit value transformation
- Server-side normalizations can affect data presentation in the frontend
- Case preservation requirements should be considered at both frontend and backend
- Data normalization strategies should be field-specific based on requirements
- Some fields require case preservation while others benefit from normalization
- Using proper button elements instead of divs with role="button" provides better accessibility and more consistent click behavior
- Click outside handlers should be added and removed based on component state to prevent memory leaks
- Removing unnecessary tabIndex attributes can improve focus management and prevent click handling issues
- Dropdown components should handle both click and focus events consistently for better user experience
- RTK Query's cache invalidation system ensures data consistency after mutations
- Using invalidatesTags with both specific and LIST tags ensures both individual and list views stay in sync
- The noValidate attribute on forms disables browser-native form validation tooltips
- Removing noValidate enables consistent form validation behavior across create and edit forms
- HTML5 form validation requires both the required attribute on inputs and form validation to be enabled
- Browser-native validation tooltips provide immediate feedback without additional error handling code
- Event handlers for MUI Select components should use consistent transformation patterns across all select fields
- Using the same event transformation helper ensures uniform event handling across different form controls
- Form validation should be applied consistently across all required fields including custom components like ColorSearch
- Required attribute works with custom form components when they properly forward the attribute to their underlying input elements
- Custom form components need their prop interfaces updated to support HTML form attributes like required
- TypeScript helps ensure form validation attributes are properly typed in component interfaces
- MUI Autocomplete components need to forward the required prop to their renderInput TextField to enable form validation
- Custom form components should properly propagate HTML form attributes to their underlying input elements
- HTML file inputs support the required attribute for form validation like other input types
- Browser-native validation works consistently for both text inputs and file uploads
- Hidden form inputs need to use visually-hidden techniques rather than display:none to support validation tooltips
- Using position:absolute and clip maintains form validation while allowing custom styled controls
- Form validation tooltips require a proper stacking context from a relatively positioned parent to scroll correctly with their inputs
- Using inline-block with relative positioning maintains both tooltip positioning and normal document flow
- MUI's sx prop can be used to style form validation messages that properly maintain their position during scrolling
- Using MUI's styling system provides better integration with its form validation behavior
- MUI's FormControl and FormHelperText provide better validation message handling than custom CSS solutions
- Using MUI's form components ensures consistent validation message behavior across different form fields
- Form inputs must remain focusable for browser validation to work properly
- Using proper visually-hidden techniques maintains accessibility and validation while hiding inputs
- MUI's FormControl with proper positioning provides better validation message behavior than custom positioning
- Browser-native validation tooltips work best when using framework-provided form components and structure
- File inputs should remain in the normal document flow to maintain proper validation behavior
- Using opacity:0 with proper positioning allows file inputs to remain focusable while visually styled
- Map marker position should only update after validating the selected location is within the US
- Location validation should happen before updating any UI elements to maintain data consistency
- User feedback should be immediate when selecting invalid locations
- Map markers should maintain their last valid position when invalid locations are selected
- Location validation should happen before triggering state updates to prevent UI flicker
- Geocoding responses should be validated before updating application state
- Map click handlers should validate location data before updating markers or form state
- User notifications should clearly indicate why a location selection was rejected
- Map markers should only move when a valid location is selected
- Location state should be preserved when invalid selections are made
- Map marker state updates should only occur after successful location validation
- Pin position should be preserved when invalid locations are selected to maintain user context
- Location validation and UI updates should be properly sequenced to prevent unwanted state changes
- UI state updates should happen after data validation to prevent flickering of invalid states
- Position marker updates should be sequenced after location validation to maintain visual consistency
- Map marker state should be synchronized with both click and search interactions
- Location updates from different sources should trigger consistent UI updates
- Map markers should respond to both direct clicks and programmatic location changes
- State initialization should be simplified to prevent race conditions with effects
- Initial state and effect updates should not duplicate logic to maintain predictable behavior
- Component mount state should be handled separately from update state for proper initialization
- Initial location data should be processed immediately on mount to ensure proper pin placement
- Multiple effects watching the same dependencies can cause state update interference
- Location state updates should be handled by a single effect to maintain consistency
- UI state updates should precede data change notifications to ensure visual feedback
- Pin placement should happen before location selection to maintain UI responsiveness
- Map component initialLocation should be updated when address search selection changes
- Address search location updates should maintain consistency with map pin placement
- Component-level state should track current map location for proper pin updates
- Address search and map click interactions should update the same location state
- Component internal state should stay synchronized with prop changes
- Location state updates should handle both initial and subsequent prop changes
- Location state updates should be consistent across all selection methods
- Map click handlers should update the same state as address search selections
- Map zoom levels should provide enough context while still showing location detail
- Auto-zoom behavior should balance between location focus and spatial awareness
- Active location selection should use different zoom levels than initial view
- Pin drop interactions should maintain broader map context while still focusing on selection
- Location selection zoom behavior should be consistent across all interaction paths
- Skip location fetch cases should maintain the same zoom behavior as normal selections
- Zoom level constants should include all map interaction scenarios
- Pin drop zoom levels should be configurable through constants

## Form Validation
- Title field validation now uses MUI Alert component to display error messages
- Error messages appear below the field when validation fails
- Validation occurs on form submission
- Replaced browser default validation with custom MUI Alert for better UI consistency
