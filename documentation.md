## New Learnings
- Consistent styling across shared components helps maintain UI uniformity between edit and create forms
- When sharing styles between components, it's important to include all style variations for MUI components (Select, Button, etc.) to maintain consistency
- Extracting shared styles to a common location helps maintain consistency and reduces duplication
- Adding MenuProps to Select components ensures consistent dropdown behavior across forms
- Consistent flex container spacing and layout structure helps maintain visual alignment between related components
- Using shared commonInputStyles across form components ensures visual consistency between edit and create forms
- Consistent MenuProps configuration helps maintain uniform dropdown behavior across the application
- Component styling consistency requires matching both the internal component styles and the wrapper/container styling
- Button styling consistency includes matching icon usage, text display, and layout spacing across similar action buttons
- Consistent image preview sizes help maintain visual harmony across different form views
- Using space-y-2 utility class provides consistent vertical spacing between form elements
- Label styling consistency is important for maintaining visual hierarchy across forms
- Maintaining consistent help text and user guidance across forms helps provide a uniform user experience
- Keeping imports clean and removing unused ones helps maintain code consistency across components
- Consistent styling for location selection components helps maintain visual harmony between create and edit forms
- Using MUI's sx prop with nested selectors allows for detailed styling control of Autocomplete and TextField components
- Maintaining consistent spacing and layout between location components helps create a unified user experience
- Ensuring consistent styling across related components (AddressSearch and LocationSelect) maintains visual coherence in the location selection feature
- Using shared style definitions like commonInputStyles helps maintain consistency even in nested components like AddressSearch
- Consistent label structure (using separate label elements instead of TextField labels) helps maintain visual hierarchy across form components
- Consistent dropdown height settings across all form components (including Autocomplete) improve visual uniformity
- Regular cleanup of unused imports helps maintain code cleanliness and reduces bundle size
- Extracting commonly used UI patterns like tips into reusable components helps maintain consistent styling and reduces duplication
- When migrating to shared components, it's important to remove duplicate fields to maintain a single source of truth
- Sharing form components between create and edit views ensures consistent user experience and reduces code duplication
- When sharing form components between edit and create forms, keeping the event handling consistent helps prevent type mismatches
- Direct handler passing is preferable to complex event transformations when the base event types are compatible
- SelectChangeEvent from MUI and React.ChangeEvent<HTMLInputElement> can be used interchangeably for basic form handling
- When integrating shared components, maintaining consistent event handling patterns helps preserve existing functionality
- When integrating shared components, adapting event handlers to match existing patterns helps maintain backwards compatibility
- When integrating shared location components, maintaining consistent location data structure helps ensure compatibility
- Using shared location selection components helps maintain consistent geocoding behavior across the application
- Consistent location display formatting between create and edit views improves user experience
- Centralizing file reading logic in shared components reduces duplication and ensures consistent behavior
- When standardizing component interfaces, updating type definitions is crucial for maintaining type safety
- When modifying shared interfaces, making fields optional helps maintain backwards compatibility
- Consistent image preview handling between create and edit forms improves user experience
- Synthetic events should be avoided when direct handler passing is possible
- Complex synthetic events can be replaced with simpler event objects that match the expected interface
- Consistent event handling patterns improve code maintainability and readability
- When standardizing interfaces, all parameters should be used consistently across implementations
- Simplifying component usage improves code maintainability and reduces potential errors
- Event handler functions that don't depend on component state should be defined outside the component
- Using proper event creation methods improves type safety over simple type assertions
- Using optional chaining for event handlers improves type safety and prevents runtime errors
- Keep event transformation logic in the component that knows about the event structure
- Standardize event handling patterns across similar form components
- Move complex event handling logic out of parent components
- Keep all related event transformation logic in one place
- Simplify component interfaces by handling transformations internally
- Reduce prop surface area when possible to improve maintainability
- Keep related state cleanup logic with the component that manages the state
- Simplify parent interfaces by moving cleanup logic into child components
- Standardize state management patterns across similar components
- Keep form field clearing logic with the component that manages the field
- Minimize parent component responsibilities for child state management
- Let child components handle their own cleanup logic
- Be explicit about event types when standardizing form interfaces
- Use type assertions judiciously to maintain compatibility with existing handlers
- Keep event type definitions focused on actually used event types
- Use optional callbacks to support different form behaviors
- Keep state management consistent while allowing for form-specific cleanup
- Make component interfaces flexible enough to handle different use cases
- Pass cleanup callbacks directly instead of wrapping in conditional logic
- Keep form-specific cleanup handlers at the form level
- Allow child components to handle common state management while forms handle specific cleanup
- Keep state management patterns identical between similar form implementations
- Avoid wrapping simple state setters in conditional logic
- Let child components fully manage their internal state transitions
- Use React naming conventions for state setters (setX instead of onXChange)
- Keep prop names consistent with their actual function
- Follow React patterns for state management props
- Combine related state changes into single handlers for clarity
- Keep state transitions predictable and centralized
- Group related state management logic together
- Extract common event creation patterns into helper functions
- Keep event creation consistent across similar handlers
- Use utility functions to reduce code duplication in event handling
- Use higher-order functions to create consistent field handlers
- Reduce boilerplate by generating similar handlers
- Keep field change handling patterns consistent
- Include all possible event types in shared component interfaces
- Make type definitions comprehensive enough to handle all use cases
- Keep event type handling consistent across form implementations
- Keep event type handling consistent from hooks to components
- Define comprehensive event types at the hook level
- Ensure form hooks can handle all component event types
- Use consistent type assertions across similar form components
- Keep event type handling identical between edit and create forms
- Apply type standardization to all component usages
- Extract common event types to reduce duplication
- Use type aliases to improve code readability
- Keep type assertions simple and consistent
- Propagate shared types through component interfaces
- Remove type assertions when interfaces match
- Keep type definitions consistent across component hierarchy
- Include all state management props in component interfaces
- Keep state setter props consistent with component usage
- Ensure parent components expose required state management functions
- Make props required when they represent core functionality
- Use no-op functions to satisfy required props when no action is needed
- Keep component interfaces identical between different usages
- Follow same naming patterns as IdentificationFields for consistency
- Use optional callbacks to handle form-specific cleanup
- Keep component interfaces aligned across similar form fields
- Keep color state cleanup logic with color component
- Use consistent state management patterns across form fields
- Follow same patterns established in IdentificationFields
- Keep state setter props consistent across form components
- Follow same state management patterns for similar fields
- Ensure parent components expose all required state setters
- Use consistent event creation patterns across form components
- Keep color validation logic with color component
- Make color state changes predictable and clear
- Extract complex validation logic into focused functions
- Keep related color validation together
- Make color conflict handling reusable
- Keep component-specific labels within components
- Encapsulate component styling for better reusability
- Remove styling duplication from parent components
- Handle both add and remove actions consistently
- Keep form-specific handlers optional but available
- Ensure all form actions have corresponding handlers
- Keep state transition logic with the component managing the state
- Handle optional callbacks in state change handlers
- Make state transitions and side effects consistent
- Order of state updates matters for form functionality
- Call parent handlers before updating local state
- Keep state transitions synchronized between parent and child
- Keep form-specific configuration in props
- Make component behavior configurable but with sensible defaults
- Handle loading states consistently across form components
- Pass form-specific loading states to shared components
- Configure zoom levels based on form context
- Keep shared component usage consistent between forms
- Extract magic numbers into named constants
- Combine loading states for better UX
- Make configuration values reusable across components
- Extract complex async operations into focused functions
- Keep related location processing logic together
- Make async state transitions more predictable
- Keep configuration constants in dedicated files
- Use TypeScript to enforce valid zoom levels
- Centralize shared configuration values
- Use shared constants instead of magic numbers
- Keep zoom level values consistent across application
- Reference shared constants directly in components
- Keep constants in organized directory structure
- Use consistent import paths across components
- Follow index.ts pattern for constants exports
- Keep interface names consistent with component names
- Use shared interfaces for similar component props
- Ensure type imports match exported names
- Use proper React event types for component callbacks
- Handle null cases in async location processing
- Add type safety to MUI component callbacks
- Use shared interfaces for common data structures
- Keep type definitions consistent across related components
- Use Partial and Omit for flexible type definitions
- Use consistent return types in location handlers
- Ensure location data matches interface at all points
- Handle optional values consistently in location data
- Propagate shared interfaces through component hierarchy
- Keep location data types consistent in map interactions
- Use shared interfaces for map click events
- Use correct import paths for shared types
- Add proper type definitions for map libraries
- Handle map event types correctly
- Keep location data types consistent in map events
- Handle map events with proper type safety
- Use shared interfaces throughout map components
- Define interfaces for internal component state
- Use consistent types for map coordinates
- Keep coordinate handling type-safe
- Use nullish coalescing for all location fields
- Ensure location data matches interface before callback
- Keep location data creation patterns consistent
- When sharing form components between edit and create forms, all required handlers must be provided for full functionality
- Keep feature parity between similar forms by providing consistent handler functions
- Make form component behavior identical between different implementations by matching all required props
- When sharing form components between edit and create forms, avoid adding unnecessary props when existing props already provide the needed functionality
- Keep component interfaces minimal by using existing props instead of creating new ones for the same functionality
- Maintain consistent behavior between forms by using the same prop patterns for similar actions
- When debugging shared form components, track state changes at both parent and child component levels to identify where state updates might be failing
- Add strategic console logs to track user interactions and state updates in form components
- When debugging function props, inspect the complete function details including toString() representation
- Add thorough prop validation checks to identify both existence and correct type of function props
- Add detailed prop validation logging to catch undefined function props early in the component lifecycle
- Use type checking and error handling to prevent runtime crashes from undefined function props
- When debugging form components with multiple instances, track individual component state to identify instance-specific issues
- Add logging to shared components to verify prop values are being passed correctly through the component hierarchy
- When debugging prop issues, track the complete prop chain from parent to child to identify where props are being lost
- Add detailed prop type and value logging to identify prop definition mismatches
- When debugging prop chain issues, verify both the type definition and the actual prop passing in parent components
- Track prop values through the entire component hierarchy to identify where required props are missing
- When sharing form functionality between create and edit modes, ensure state management hooks are consistently used in both components
- Verify that state management hooks are properly initialized in both create and edit modes
- When using custom hooks, ensure all state setters are properly exposed in the hook's return object
- Verify that state setters are correctly passed through the entire component chain
- Check hook implementation when state management isn't working in one component but works in another
- When state setters aren't working, check if they're properly returned from custom hooks
- Ensure all required state management functions are included in hook return objects
- Verify hook implementation matches between create and edit forms for shared functionality
- Remove debugging logs once functionality is fixed to keep code clean
- Clean up temporary debugging code after resolving issues
- Maintain code cleanliness by removing diagnostic logging after debugging
- When using state management hooks, ensure all required state setters are properly destructured and passed down to child components
- TypeScript linting can help identify missing props that could cause runtime errors
- Optional callback props should be handled with optional chaining, while required state setters should be called directly
- Props interfaces must properly type state setter functions to avoid runtime errors
- State setter functions should be explicitly typed and wrapped when passed as props to ensure proper binding
- Component-level state management should be handled at the container level when dealing with edit/view modes
- Tailwind's space utilities should be adjusted based on component hierarchy and visual design requirements
- Nested space utilities should be carefully considered to avoid compounding spacing effects
- Consistent spacing between form sections improves visual hierarchy and readability
- Match spacing patterns across similar form components for visual consistency
- State management should be handled by the custom hook rather than component-level useState
- Verify state setter functions are properly typed in component prop interfaces
- Custom hooks must explicitly return all required state setters in their return object
- Order state transitions carefully to ensure proper synchronization between parent and child components
- Reusable UI components like buttons should include customizable labels for better accessibility and reuse
- When extracting common UI patterns, consider both visual consistency and semantic meaning
- Using default prop values allows components to maintain backwards compatibility while adding new features
- Component extraction should preserve existing data-testid patterns for testing consistency
- When extracting shared components, ensure test coverage remains consistent by preserving testIds
- Maintain consistent testIds across multiple instances of the same component type
