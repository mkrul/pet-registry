## New Learnings

- RTK Query cache invalidation requires careful configuration of provideTags and invalidatesTags to ensure proper cache updates
- When dealing with image updates, it's important to properly invalidate both individual item caches and list caches
- Using refetchOnMountOrArgChange can help ensure data freshness when navigating between pages
- For mobile-responsive search functionality, using a fixed position tab with smooth animations provides better UX
- Framer Motion can be used to create smooth slide-in/out animations for mobile interfaces
- Using Tailwind's md breakpoint (768px) effectively covers requirements for mobile-specific features targeting screens under 749px
- OpenStreetMap API returns various road/path types (road, footway, path, cycleway, etc.) that need to be handled for accurate intersection data
- When working with OpenStreetMap data, it's important to handle multiple possible field names for similar features
- When debugging complex data transformations, it's helpful to log intermediate steps to understand where the logic might be failing
- OpenStreetMap API requires different zoom levels to find different types of location data - wider zoom helps find nearby streets
- OpenStreetMap's search API with viewbox parameter can be used to find nearby streets within a specific radius
- Overpass API is more reliable than OpenStreetMap's search API for finding nearby streets within a specific radius
- When working with street data, it's important to filter by highway types to get relevant results
- Overpass API queries need to include the 'name' tag to filter for named streets only
- OpenStreetMap address data can be used to determine urban vs rural areas for adjusting search parameters
- In rural areas, OpenStreetMap data might require wider zoom levels and search radii to find roads
- Leaflet marker icons need explicit configuration in React applications to work correctly in production builds
- Default marker icons must be imported and configured using L.Icon.Default.mergeOptions for proper bundling
- Using window.history.back() provides better UX by maintaining scroll position when returning to previous page
- Browser's native history management helps preserve page state between navigations
- Managing scroll position in Redux state provides reliable scroll restoration between page navigations
- Custom hooks can provide cleaner solutions for managing UI behaviors like scroll position restoration
- Scroll position management should be handled at specific user interaction points (navigation, reset, etc.)
- When restoring scroll position, it's important to wait for the page to render using requestAnimationFrame
- Pagination actions should reset scroll position to improve user experience
- Using key prop to force component remount can prevent unwanted content flashes during updates
- When detecting street intersections, using a smaller initial search radius (100m) with a fallback to a larger radius (200m) provides more accurate results
- Filtering OpenStreetMap highway types to include only proper roads (primary, secondary, tertiary, residential, unclassified) improves intersection detection accuracy
- Overpass API queries should be structured to return roads in order of proximity to the target point
