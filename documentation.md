## New Learnings
- Only include instructional messages where they provide relevant context
- Differentiate between new report creation and editing workflows
- Use consistent label styling (text-sm, font-medium, text-gray-900) across related forms
- Use semantic HTML elements (label instead of h3) for form field labels
- Maintain consistent label styling even for read-only sections
- Pay attention to exact font sizes when matching styles between components
- Use text-base for form labels to ensure better readability
- Show location feedback in both edit and view modes for better user experience
- Maintain consistent location display patterns across form states
- Reuse successful UI patterns across related components
- Maintain consistent location feedback across all form variants
- Pay attention to subtle label text differences between forms
- Maintain consistent button widths for similar actions
- Use consistent image preview sizes across forms
- Avoid using placeholder text in select inputs for better UX consistency
- Keep form input behavior consistent across similar forms
- Remove placeholder text from all select inputs for consistent user experience
- Apply consistent dropdown patterns across all form sections
- Use consistent button styles for similar actions (like remove buttons)
- Prefer icon-only buttons for common actions to reduce visual clutter
- Use subtle hover effects instead of error colors for common actions like remove buttons
- Maintain consistent button styling across forms by avoiding variant and color props when matching existing designs
- Pay attention to exact button padding and icon sizes for visual consistency
- Use lighter colors and smaller icons for secondary actions to maintain visual hierarchy
- Reuse existing component styles when available instead of creating new variations
- Use consistent icon components (MUI vs FontAwesome) within the same context
- Use consistent button components (MUI Button vs HTML button) across related forms
- Maintain consistent text button styling using MUI's variant="text" and color="primary"
- Apply consistent button styling patterns across all similar actions in forms
- Use MUI Button component consistently for all action buttons in forms
- Use consistent form validation across related forms
- Validate forms on the frontend before making API calls to improve user experience
- Reuse existing validation logic to maintain consistency across forms
- Consider both new and existing data when implementing form validation
- Check for existing assets before requiring new uploads in edit forms
- Ensure interface field types match between related interfaces to maintain type compatibility
- Make form interfaces compatible with API response interfaces for seamless data handling
- Ensure all nullable fields are consistently marked as nullable across related interfaces
- Handle nullable form values by converting null to empty string for MUI Select components
- Split complex form components into view/edit modes for better separation of concerns
- Extract form action logic into custom hooks for reusability
- Use existing form section components to maintain consistency
- Define explicit prop interfaces for form mode components
- Avoid spreading undefined props to child components
- Maintain strict typing for event handlers in form components
- Ensure event handler types are compatible with all child component requirements
- Use consistent null checks for all optional date fields in form data
- Learned how to test LogoutButton component's logout functionality using Vitest and React Testing Library
- Use Vitest's mocking utilities for consistent test behavior
- Properly mock Redux hooks in component tests
- Test both success and error scenarios for async operations
- Use proper assertion timing with waitFor for async operations
- Follow established patterns for Redux store mocking in tests
- Use proper type imports for test mocks to maintain type safety
- Properly type test utilities and mocks to catch potential issues early
- Follow consistent type import patterns across test files
- Empty test files will cause Vitest to report no test suites found
- Always implement complete test cases with proper assertions
- Use proper typing for test utilities to maintain type safety
