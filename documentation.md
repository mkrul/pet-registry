## New Learnings
- Only include instructional messages where they provide relevant context
- Differentiate between new report creation and editing workflows
- Use consistent label styling (text-sm, font-medium, text-gray-900) across related forms
- Use semantic HTML elements (label instead of h3) for form field labels
- Maintain consistent label styling even for read-only sections
- Pay attention to exact font sizes when matching styles between components
- Use text-base for form labels to ensure better readability
- Show location feedback in both edit and view modes for better user experience
- Maintain consistent location display patterns across form states
- Reuse successful UI patterns across related components
- Maintain consistent location feedback across all form variants
- Pay attention to subtle label text differences between forms
- Maintain consistent button widths for similar actions
- Use consistent image preview sizes across forms
- Avoid using placeholder text in select inputs for better UX consistency
- Keep form input behavior consistent across similar forms
- Remove placeholder text from all select inputs for consistent user experience
- Apply consistent dropdown patterns across all form sections
- Use consistent button styles for similar actions (like remove buttons)
- Prefer icon-only buttons for common actions to reduce visual clutter
- Use subtle hover effects instead of error colors for common actions like remove buttons
- Maintain consistent button styling across forms by avoiding variant and color props when matching existing designs
- Pay attention to exact button padding and icon sizes for visual consistency
- Use lighter colors and smaller icons for secondary actions to maintain visual hierarchy
- Reuse existing component styles when available instead of creating new variations
- Use consistent icon components (MUI vs FontAwesome) within the same context
- Use consistent button components (MUI Button vs HTML button) across related forms
- Maintain consistent text button styling using MUI's variant="text" and color="primary"
- Apply consistent button styling patterns across all similar actions in forms
- Use MUI Button component consistently for all action buttons in forms
- Use consistent form validation across related forms
- Validate forms on the frontend before making API calls to improve user experience
- Reuse existing validation logic to maintain consistency across forms
- Consider both new and existing data when implementing form validation
- Check for existing assets before requiring new uploads in edit forms
- Ensure interface field types match between related interfaces to maintain type compatibility
- Make form interfaces compatible with API response interfaces for seamless data handling
- Ensure all nullable fields are consistently marked as nullable across related interfaces
- Handle nullable form values by converting null to empty string for MUI Select components
- Split complex form components into view/edit modes for better separation of concerns
- Extract form action logic into custom hooks for reusability
- Use existing form section components to maintain consistency
- Define explicit prop interfaces for form mode components
- Avoid spreading undefined props to child components
- Maintain strict typing for event handlers in form components
- Ensure event handler types are compatible with all child component requirements
- Use consistent null checks for all optional date fields in form data
- Learned how to test LogoutButton component's logout functionality using Vitest and React Testing Library
- Use Vitest's mocking utilities for consistent test behavior
- Properly mock Redux hooks in component tests
- Test both success and error scenarios for async operations
- Use proper assertion timing with waitFor for async operations
- Follow established patterns for Redux store mocking in tests
- Use proper type imports for test mocks to maintain type safety
- Properly type test utilities and mocks to catch potential issues early
- Follow consistent type import patterns across test files
- Empty test files will cause Vitest to report no test suites found
- Always implement complete test cases with proper assertions
- Use proper typing for test utilities to maintain type safety
- Mock window methods properly in test environment
- Test React Router hook behavior in isolation
- Verify side effects in components without DOM output
- Implement strict location validation against exact "United States" string from OpenStreetMap API
- Handle location validation consistently across map interactions
- Implement early returns for non-US location selections to prevent unnecessary processing
- Add test coverage for US-only location validation in Map component
- Handle async state updates properly in Map component tests
- Mock location API responses consistently in tests
- Use React Testing Library's act for handling async state updates in tests
- Properly mock external libraries like Leaflet in React component tests
- Handle complex component interactions in tests with proper async patterns
- Use role-based queries in tests for better accessibility and reliability
- Implement proper text content matching in notification tests
- Handle notification state changes in tests with proper async patterns
- Implement user feedback for invalid location selections with notifications
- Clear notifications automatically when valid selections are made
- Display location validation notifications above map component
- Use space-y utility for consistent vertical spacing
- Lift notification state to parent component for better positioning
- Maintain consistent text sizes across all notification types
- Use responsive text styling for notifications
- Ensure notification styling consistency across different contexts
- Use consistent font weights for notification messages
- Standardize text styling across all notification types
- Ensure consistent font weight in notification containers
- Maintain consistent punctuation in notification messages
