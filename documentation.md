## New Learnings
- Gender field is now restricted to "Male" and "Female" options only
- Gender field can be left blank if unknown
- Gender values are case-normalized between frontend and backend
- Altered status uses numeric values (1/0/null) consistently throughout the application stack
- Altered status values are validated in both frontend and backend
- Altered status is handled consistently across services and seeds
- Seed data includes altered status for all reports
- Altered status values are normalized to handle empty/nil values consistently
- Altered status is displayed in human-readable format in view mode
- Form population correctly sets altered status radio selection
- Radio group values need consistent handling between null and empty string
- Altered status needs proper initialization in form state
- Form submission needs to include altered status field
- Altered status parameter needs to be permitted in controller
- Controller needs to handle both numeric and boolean string values for altered status
- Rails enum handles altered status conversion automatically
- Altered status normalization needs to handle numeric string conversion
- Altered status needs single consistent normalization
- Altered status normalization needs to preserve nil values
- Form field error displays should be consistent across all form components
- Error alerts should be positioned consistently below their respective fields
- Error display logic should be centralized in a reusable component
- Remove unused imports when centralizing component functionality to maintain clean code
- Ensure all components are cleaned up when centralizing shared functionality
- Form validation errors are more effective when displayed next to their respective fields
- Field-level error state should be managed at the form level
- Validation messages should be clear and contextual to their fields
- Material-UI RadioGroup treats undefined value as truly unselected, while empty string can be treated as a selectable value
- Form validation should include all required fields, including radio group selections
- Error messages for radio groups should follow the same pattern as other form fields
- Field-specific errors need to be properly passed to FormFieldError components
- Required field validation alerts should be consistent across all required form fields
- Validation error messages should follow consistent phrasing pattern across all required fields
- Altered status validation message should specifically mention spayed/neutered status
- Form validation should check altered status before species selection
- Form field errors should be passed specifically to their respective form fields for proper display
- Radio buttons should show error state styling consistent with other form inputs
- Radio button validation errors should only show error message without visual styling on the buttons
- Form validation logic should be separated from form components for better maintainability
- Validation error handling should be centralized to ensure consistent behavior
- DOM manipulation for validation feedback should be handled by validation service
- Form components should focus solely on form state and user interaction handling
- TypeScript interfaces should be updated when adding new error props to components
- Error state initialization should be centralized in validation service for consistency
- Location validation should be handled by validation service for consistency
- Validation services should import all required types directly
- Framework-specific types should be isolated in validation services
- DOM selectors should be typed for better maintainability
- Backend validation errors should be displayed inline with form fields for consistency
- Use "server" instead of "backend" in naming for clarity
- Use domain-specific naming for validation error handling
- Use consistent error display pattern (field alerts) instead of multiple systems
- Server validation errors should be mapped to specific form fields for proper display
- Form submission hooks should focus on data transformation, not error display
- Remove unused notification imports when switching to field-level alerts
- Form data transformation should be handled by a dedicated utility
- Form data utilities should import their required types directly
- Remove notification-related hooks when switching to field alerts
- Include all form fields in server validation error mapping
- Form field components need to handle their own error displays
- Maintain consistent input styling across form fields
- Backend validation errors should be handled consistently with frontend validation errors
- Form submission hooks should return proper response types for error handling
- Backend validation errors should trigger the same visual feedback as frontend validation
- RTK Query mutation responses need to be handled without unwrap() for proper error handling
- Backend validation errors need to be extracted from the RTK Query error response structure
- Error handling should preserve the original error structure for proper type checking
- MUI RadioGroup must maintain consistent controlled state throughout component lifecycle
- Radio button values should be normalized to strings for controlled components
- Form population should maintain consistent value types for radio inputs
- Error mapping needs detailed logging to trace validation flow
- Server error structure needs verification at each transformation step
- Form submission validation chain needs end-to-end tracking
- Backend validation messages can come in different formats (errors object vs message string)
- Error handling needs to handle both structured and simple message formats
- Error mapping should convert single message responses into field-specific format
- Backend validation messages need to be mapped to specific fields based on content
- Error field detection should use pattern matching for flexible message handling
- Single message validation errors need intelligent field mapping
- Error message objects should be passed through validation chain without premature field mapping
- Field mapping should happen at the validation service level for consistency
- Error scrolling should use the same field mapping as validation display
- Utility functions used across components need to be explicitly exported
- Field mapping utilities should be accessible to both validation and form components
- Error handling utilities should be part of the public validation API
- Basic info field validation patterns need to be comprehensive
- Field mapping should include all possible backend validation fields
- Location field should be included in field mapping for completeness
- Field patterns should handle variations in backend error message terminology
- Field mapping should handle both snake_case and camelCase backend field names
- Microchip validation needs to handle both full and abbreviated terms
- Backend error messages for IDs need more flexible pattern matching
- Field pattern matching should include fallback patterns for common terms
- Microchip validation needs to handle compound term variations
- Error props need to be passed to all form field components
- Form field components need to handle all possible validation errors
- Error display needs to be consistent across all input fields
- Field mapping process needs detailed logging for debugging
- Error field resolution needs to be logged before error handling
- Validation flow needs logging at each transformation step
- Error props need to be passed through from form state to child components
- Field error state needs to be connected to component display props
- Validation state needs to be properly propagated to form fields
- Error field selectors need to include all form input fields
- Scroll behavior needs to be consistent across all validation errors
- Field selectors need to match exact input name attributes
- Form validation system should be fully migrated to one consistent approach
- Legacy notification code should be removed after migration
- Import statements should be cleaned up after feature migration
- API endpoints should be cleaned up after validation system migration
- Redux slice transformations should be simplified after validation changes
- API error handling should be consistent with form-level validation
- RTK Query error responses need proper TypeScript interfaces
- Error response types should include both message and errors fields
- FetchBaseQueryError needs to be extended for custom error data
- API error types should be centralized in redux type definitions
- Error response interfaces should be exported from API type files
- Error types should be reusable across components
- API response types need to include optional data field
- Response interfaces should handle both success and error cases
- Type definitions should cover all possible response structures
- RTK Query response types need explicit type assertions
- Error and success responses need consistent return types
- Response type handling needs to cover all code paths
- Missing type imports can cause TypeScript errors in response handling
- Submit response types need to be imported alongside error types
- Type imports should be grouped by source file
- Validation error responses need their own interface
- Error responses need to match success response shape
- Response types need to handle partial data structures
- RTK Query response types may need type assertions with unknown
- Response type coercion needs to handle complex type hierarchies
- Type assertions should be used when type inference fails
- RTK Query success responses need proper structure mapping
- Response data needs to be transformed to match expected interface
- Success case needs to maintain consistent response shape
- FormInputEvent type needs to extend React's ChangeEvent for proper form handling
- ReportPropsForm interface needs to include all form fields with proper types
- Type assertions should be avoided when possible in favor of proper type definitions
- Component props interfaces should be updated when adding new error handling props
- Component type definitions need to import their dependent types explicitly
- Interface files should import all required types rather than relying on global types
- Form hooks need explicit type definitions for state and handlers
- Form state initialization should include all possible form fields with proper types
- Form hooks should accept properly typed partial initial data
- React state setter types should use Dispatch and SetStateAction
- Callback dependencies should be minimal to prevent unnecessary rerenders
- React imports should be granular to reduce bundle size
- Form event types need to be properly constrained to HTMLFormElement
- Form submission handlers need explicit return type annotations
- RTK Query response handling needs proper type narrowing
- Validation error types need to include an index signature for dynamic field errors
- ValidationErrors interface should list all possible form field errors
- Validation error fields should be non-optional when used with form validation services
- SubmitResponse interface needs to include both report and data fields for type consistency
- API response transformations need to explicitly return the full expected type structure
- Response interfaces may need to extend base types to inherit required fields
- Form field types need to match their backend counterparts (e.g., altered status as 0 | 1 | null)
- Component props that receive state setters should use Dispatch<SetStateAction> type
- Type imports should be consistent across components to avoid type mismatches
- Form event types need to handle multiple input element types (input/textarea)
- Form event types need to handle Material-UI's SelectChangeEvent alongside native events
- Form event types should be simplified to only include required properties
- Component prop interfaces need to be updated when adding new error fields
- Component prop interfaces need to be defined in both types and component files
- Form submission hooks need to handle navigation in a centralized location
- Success notifications should be dispatched in the submission hook where we have access to the API response
- Notification display should be centralized in App.tsx to prevent duplicate notifications
- Backend success messages should be accessed from response.data for proper handling
- Report status indicators need to prioritize "NEW" over "UPDATED" state
- Recently created reports should not be marked as updated
- Report status timing needs precise second-level accuracy
- Status calculations should use consistent time comparisons
- Form field dependencies should provide immediate user feedback
- Container-level event handling provides better control than prop drilling
- MUI Autocomplete requires comprehensive slot handling for complete click coverage
- Form field interactions should handle all possible user interaction points
- MUI TextField InputProps provide direct access to input click events
- Form field click handling should use native input event propagation
- Form field placeholders should guide users through required steps
- Input fields should provide context-aware placeholder text
- Placeholder text should maintain sufficient contrast for readability
- MUI TextField placeholder styles can be customized through InputBase selectors
- Form warning states should clear automatically when requirements are met
- Form field dependencies should handle both show and hide conditions
- Form warning states should stay synchronized with form data
- React effects should handle derived state updates
- Form state updates should be handled directly in event handlers when possible
- Avoid useEffect for state updates that can be handled synchronously
- Form field warnings should only trigger when conditions are unmet
- Input interactions should validate current state before showing warnings
- Form field removal should follow consistent patterns
- State management utilities should handle similar operations uniformly
- Form field state should be initialized directly from props
- Avoid unnecessary effects for state synchronization
- Component removal should include proper transition animations
- MUI Collapse provides consistent enter/exit animations
- Animation state should be controlled by parent components
- Transition components need explicit visibility control
- Component handlers should use props for state updates
- Field removal should handle both local and parent state
- Form state setters must be properly destructured and passed
- Component state management requires consistent prop passing
- Form field spacing should follow consistent patterns
- Component layout patterns should be standardized across similar components
- Form field margins should be consistent across similar sections
- Vertical spacing should follow established component patterns
- Form field spacing requires proper nesting structure
- Component spacing should use consistent hierarchy patterns
- Form section spacing should use consistent gap values
- Tailwind spacing classes should align across similar components
- Form spacing needs different values for different element types
- Vertical rhythm requires balanced spacing between related elements
- Button elements should inherit parent container spacing
- Form spacing should minimize wrapper element margins
- Similar form sections should share identical spacing patterns
- Form field groups should maintain consistent visual hierarchy
- Optional field spacing should be added conditionally
- Form spacing should reflect field visibility state
- State updates for field removal should follow consistent order
- Field visibility state should be updated last in removal sequence
- Form event handlers must maintain core input functionality
- State updates should preserve essential form operations
- Related form fields should adjust spacing based on siblings
- Container margins should adapt to field visibility state
- Form field containers need proper nesting for margin control
- Dynamic margins require correct container hierarchy
- Form button spacing needs consistent parent container gaps
- Container spacing should handle both static and dynamic margins
- Action buttons need tighter spacing with related inputs
- Form spacing intervals should reflect element relationships